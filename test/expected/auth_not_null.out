-- avoid ts, xact_id differences in output
\set VERBOSITY terse
\set SHOW_CONTEXT never
-- Scenario 1: auth functions exist & return NULL -> insert should ERROR
begin;
    \set ECHO none
    select audit.enable_tracking('public.af_members1');
 enable_tracking 
-----------------
 
(1 row)

    insert into public.af_members1 values('11111111-1111-1111-1111-111111111111', 'fail'); -- expect ERROR
psql:test/sql/auth_not_null.sql:19: ERROR:  null value in column "auth_uid" of relation "record_version" violates not-null constraint
rollback;
-- Scenario 2: auth functions exist (from auth.sql), no GUCs set -> insert should ERROR with custom message
begin;
    \set ECHO none
    select audit.enable_tracking('public.af_members2');
 enable_tracking 
-----------------
 
(1 row)

    insert into public.af_members2 values('22222222-2222-2222-2222-222222222222', 'fail'); -- expect error
psql:test/sql/auth_not_null.sql:34: ERROR:  auth.uid(): current_setting('auth.user_id') must not be empty. Call auth.set_context(user_id, role) to set it.
rollback;
-- Scenario 3: No auth functions at migration time -> no auth columns -> no enforcement
begin;
    \set ECHO none
    select audit.enable_tracking('public.af2');
 enable_tracking 
-----------------
 
(1 row)

    insert into public.af2 values(1);
    -- Show that no auth_* columns exist
    select column_name from information_schema.columns where table_schema='audit' and table_name='record_version' and column_name like 'auth_%' order by 1;
 column_name 
-------------
(0 rows)

    select op, (record->>'id') as id from audit.record_version;
   op   | id 
--------+----
 INSERT | 1
(1 row)

rollback;
\set VERBOSITY default
\set SHOW_CONTEXT errors
